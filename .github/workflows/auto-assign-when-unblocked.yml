# .github/workflows/auto-assign-when-unblocked.yml
name: Auto-assign when unblocked

on:
  issues:
    types: [opened, edited, reopened, labeled, unlabeled, closed, transferred]
  pull_request:
    types: [closed]
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  pull-requests: read

concurrency:
  group: auto-assign-when-unblocked-${{ github.run_id }}
  cancel-in-progress: false

jobs:
  assign-when-unblocked:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' ||
      (github.event_name == 'pull_request' && github.event.action == 'closed') ||
      github.event_name == 'workflow_dispatch'

    steps:
      - name: Determine targets (dependants to re-check)
        id: targets
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const targets = new Set();
            let closedNumber = null;

            // Collect linked issues (direction-agnostic) via GraphQL ConnectedEvent
            async function collectConnectedIssuesByGraphQL(issueNumber) {
              // 1) get node id for the issue
              const q1 = `
                query ($owner:String!, $repo:String!, $number:Int!) {
                  repository(owner:$owner, name:$repo) {
                    issue(number:$number) { id number }
                  }
                }`;
              const r1 = await github.graphql(q1, { owner, repo, number: issueNumber });
              const nodeId = r1?.repository?.issue?.id;
              if (!nodeId) return;

              // 2) fetch ConnectedEvent subjects
              const q2 = `
                query ($id:ID!) {
                  node(id:$id) {
                    ... on Issue {
                      timelineItems(first: 200, itemTypes: [CONNECTED_EVENT]) {
                        nodes {
                          __typename
                          ... on ConnectedEvent {
                            subject {
                              __typename
                              ... on Issue { number }
                              ... on PullRequest { number }
                            }
                          }
                        }
                      }
                    }
                  }
                }`;
              const r2 = await github.graphql(q2, { id: nodeId });
              const nodes = r2?.node?.timelineItems?.nodes || [];
              for (const n of nodes) {
                const subj = n?.subject;
                if (!subj) continue;
                if (subj.__typename === 'Issue' && typeof subj.number === 'number') {
                  targets.add(subj.number);
                }
                // We only assign issues, not PRs
              }
            }

            // If a PR closes, re-check issues it blocks (via timeline REST)
            async function collectDependantsFromTimeline(number) {
              const iterator = github.paginate.iterator(
                github.rest.issues.listEventsForTimeline,
                { owner, repo, issue_number: number, per_page: 100, mediaType: { previews: ['mockingbird'] } }
              );
              for await (const { data } of iterator) {
                for (const ev of data) {
                  if (ev.event !== 'connected') continue;
                  const reason = ev.reason || ev.connection_type || '';
                  if (reason !== 'blocks') continue;
                  const subj = ev.subject || {};
                  // subject.number may be missing; fall back to parsing URL
                  let n = typeof subj.number === 'number' ? subj.number : undefined;
                  if (!n) {
                    const url = subj.html_url || subj.url || '';
                    const m = url.match(/\/issues\/(\d+)(?:$|[/?#])/);
                    if (m) n = parseInt(m[1], 10);
                  }
                  if (n) targets.add(n);
                }
              }
            }

            if (context.eventName === 'issues') {
              const issueNum = context.payload.issue.number;
              if (context.payload.action === 'closed') {
                closedNumber = issueNum;
                // Use GraphQL to fetch all connected issues (direction-agnostic)
                await collectConnectedIssuesByGraphQL(issueNum);
              } else if (['opened','edited','reopened','labeled','unlabeled','transferred'].includes(context.payload.action)) {
                targets.add(issueNum); // re-check self on edits
              }
            } else if (context.eventName === 'pull_request') {
              // PR closed: re-check issues it *blocks*
              if (context.payload.action === 'closed') {
                await collectDependantsFromTimeline(context.payload.pull_request.number);
                closedNumber = null; // not strictly needed here
              }
            }

            const list = Array.from(targets);
            core.info(`Collector → targets: ${JSON.stringify(list)} ; closedNumber: ${closedNumber}`);
            core.setOutput('list', JSON.stringify(list));
            if (closedNumber !== null) core.setOutput('closed', String(closedNumber));

      - name: Assign any now-unblocked issues
        if: steps.targets.outputs.list != ''
        uses: actions/github-script@v7
        env:
          TARGETS: ${{ steps.targets.outputs.list }}
          CLOSED_NUMBER: ${{ steps.targets.outputs.closed }}
          DEFAULT_ASSIGNEE: ${{ vars.DEFAULT_ASSIGNEE }}            # e.g. "smcnab1" or "nexoroid,smcnab1"
          BLOCKED_LABEL: ${{ vars.BLOCKED_LABEL }}                  # optional gate
          REMOVE_LABEL_ON_ASSIGN: ${{ vars.REMOVE_LABEL_ON_ASSIGN }}# optional cleanup
        with:
          script: |
            const { owner, repo } = context.repo;

            function extractIssueNumber(subject) {
              if (!subject) return undefined;
              if (typeof subject.number === 'number') return subject.number;
              const url = subject.html_url || subject.url || '';
              const m = url.match(/\/issues\/(\d+)(?:$|[/?#])/);
              return m ? parseInt(m[1], 10) : undefined;
            }

            async function candidateHasBlockedBy(candidateNumber, blockerNumber) {
              // Verify the candidate actually has a 'blocked_by' link to the closed issue
              const iterator = github.paginate.iterator(
                github.rest.issues.listEventsForTimeline,
                { owner, repo, issue_number: candidateNumber, per_page: 100, mediaType: { previews: ['mockingbird'] } }
              );
              for await (const { data } of iterator) {
                for (const ev of data) {
                  if (ev.event !== 'connected') continue;
                  const reason = ev.reason || ev.connection_type || '';
                  if (reason !== 'blocked_by') continue;
                  const n = extractIssueNumber(ev.subject);
                  if (n === blockerNumber) return true;
                }
              }
              return false;
            }

            async function listOpenBlockers(candidateNumber) {
              const openBlockers = new Set();
              const iterator = github.paginate.iterator(
                github.rest.issues.listEventsForTimeline,
                { owner, repo, issue_number: candidateNumber, per_page: 100, mediaType: { previews: ['mockingbird'] } }
              );
              for await (const { data } of iterator) {
                for (const ev of data) {
                  if (ev.event !== 'connected') continue;
                  const reason = ev.reason || ev.connection_type || '';
                  if (reason !== 'blocked_by') continue;
                  const n = extractIssueNumber(ev.subject);
                  if (typeof n === 'number') openBlockers.add(n);
                }
              }
              const stillOpen = [];
              for (const n of openBlockers) {
                try {
                  const r = await github.rest.issues.get({ owner, repo, issue_number: n });
                  if (r.data.state !== 'closed') stillOpen.push(n);
                } catch {
                  // conservative: treat as open
                  stillOpen.push(n);
                }
              }
              return stillOpen;
            }

            async function getIssue(n) {
              const r = await github.rest.issues.get({ owner, repo, issue_number: n });
              return r.data;
            }

            const targets = JSON.parse(process.env.TARGETS || '[]');
            const closedStr = (process.env.CLOSED_NUMBER || '').trim();
            const closedNumber = closedStr ? parseInt(closedStr, 10) : null;

            for (const n of targets) {
              const issue = await getIssue(n);
              if (!issue || issue.pull_request) continue; // skip PRs
              if (issue.state === 'closed') continue;

              // If we have a closedNumber, insist this candidate was *blocked by* that specific issue
              if (closedNumber !== null) {
                const hadLink = await candidateHasBlockedBy(issue.number, closedNumber);
                if (!hadLink) {
                  core.info(`#${issue.number}: not actually 'blocked_by' closed #${closedNumber} → skip`);
                  continue;
                }
              }

              const blockedLabel = (process.env.BLOCKED_LABEL || '').trim().toLowerCase();
              const hasBlockedLabel = blockedLabel
                ? (issue.labels || []).some(l => (typeof l === 'string' ? l : l.name).toLowerCase() === blockedLabel)
                : true;

              const openBlockers = await listOpenBlockers(issue.number);

              if (openBlockers.length === 0 && hasBlockedLabel) {
                const configured = (process.env.DEFAULT_ASSIGNEE || '').trim();
                const candidates = configured
                  ? configured.split(',').map(s => s.trim()).filter(Boolean)
                  : [issue.user?.login || owner];

                const already = (issue.assignees || []).map(a => a.login.toLowerCase());
                const toAssign = candidates.filter(c => !already.includes(c.toLowerCase()));

                if (toAssign.length > 0) {
                  await github.rest.issues.addAssignees({ owner, repo, issue_number: issue.number, assignees: toAssign });
                  core.info(`Assigned #${issue.number} → ${JSON.stringify(toAssign)}`);
                } else {
                  core.info(`#${issue.number}: already assigned to one of ${JSON.stringify(candidates)}`);
                }

                const removeLabel = (process.env.REMOVE_LABEL_ON_ASSIGN || '').trim().toLowerCase();
                if (removeLabel) {
                  const hasLabel = (issue.labels || []).some(l => (typeof l === 'string' ? l : l.name).toLowerCase() === removeLabel);
                  if (hasLabel) {
                    try {
                      await github.rest.issues.removeLabel({ owner, repo, issue_number: issue.number, name: removeLabel });
                    } catch (e) {
                      core.info(`Could not remove label '${removeLabel}': ${e.message}`);
                    }
                  }
                }
              } else {
                core.info(`#${issue.number}: still has ${openBlockers.length} open blocker(s) or failed label gate`);
              }
            }
