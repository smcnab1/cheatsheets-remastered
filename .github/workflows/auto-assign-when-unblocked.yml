name: Auto-assign when unblocked

on:
  issues:
    types:
      # Cover link edits, label changes, reopen, and when a blocker closes
      - opened
      - edited
      - reopened
      - labeled
      - unlabeled
      - closed
  # Re-evaluate when a PR closes, in case blockers are PRs
  pull_request:
    types: [closed]

permissions:
  issues: write
  contents: read

concurrency:
  group: auto-assign-when-unblocked-${{ github.event_name }}-${{ github.event.issue.number || github.event.pull_request.number || 'na' }}
  cancel-in-progress: false

jobs:
  assign-when-unblocked:
    name: Assign when all blockers are resolved
    runs-on: ubuntu-latest

    # Only run for issues in this repository (skip PR events except to re-check blocked issues they were blocking)
    if: |
      (github.event_name == 'issues') ||
      (github.event_name == 'pull_request' && github.event.action == 'closed')

    steps:
      - name: Determine target issues to evaluate
        id: targets
        uses: actions/github-script@v7
        with:
          script: |
            const isIssueEvent = context.eventName === 'issues';
            const repo = context.repo;
            const targets = [];

            if (isIssueEvent) {
              // Evaluate the current issue
              targets.push({ number: context.payload.issue.number });
            } else {
              // A PR closed: find issues that PR "blocks" and re-evaluate those
              // (We’ll look for linked issues with "BLOCKS" from this PR)
              const prNodeId = context.payload.pull_request.node_id;
              const q = `
                query ($nodeId: ID!) {
                  node(id: $nodeId) {
                    ... on PullRequest {
                      id
                      number
                      timelineItems(first: 100, itemTypes: [CONNECTED_EVENT]) {
                        nodes {
                          ... on ConnectedEvent {
                            subject {
                              __typename
                              ... on Issue { number }
                            }
                          }
                        }
                      }
                      # Use GraphQL linkedIssues API (blocks)
                      linkedIssues(first: 100, relationship: BLOCKS) {
                        nodes { number }
                      }
                    }
                  }
                }
              `;
              const data = await github.graphql(q, { nodeId: prNodeId });
              const nodes = new Set();
              // timelineItems may not include link types; prefer linkedIssues
              if (data.node?.linkedIssues?.nodes) {
                for (const n of data.node.linkedIssues.nodes) {
                  if (n?.number) nodes.add(n.number);
                }
              }
              targets.push(...[...nodes].map(n => ({ number: n })));
            }

            core.setOutput('list', JSON.stringify(targets));

      - name: Assign any now-unblocked issues
        uses: actions/github-script@v7
        env:
          # Configure who to assign:
          # Prefer a repo/org Variable named DEFAULT_ASSIGNEE (Settings → Variables → Repository/Organisation),
          # otherwise fall back to the repo owner.
          DEFAULT_ASSIGNEE: ${{ vars.DEFAULT_ASSIGNEE }}
          # Optional: only act if the issue currently has this label (e.g., "blocked").
          # Leave empty to ignore label gating.
          BLOCKED_LABEL: ${{ vars.BLOCKED_LABEL }}
          # Optional: label to remove when assigning (e.g., "blocked")
          REMOVE_LABEL_ON_ASSIGN: ${{ vars.REMOVE_LABEL_ON_ASSIGN }}
        with:
          script: |
            const repo = context.repo;
            const targets = JSON.parse(core.getInput('list', { required: true }) || '[]');

            // Helper: fetch linked "blocked by" issues for a given issue
            async function getOpenBlockers(issueNumber) {
              const q = `
                query ($owner:String!, $repo:String!, $number:Int!) {
                  repository(owner:$owner, name:$repo) {
                    issue(number:$number) {
                      number
                      state
                      labels(first: 50) { nodes { name } }
                      assignees(first: 10) { nodes { login } }
                      author { __typename login }
                      linkedIssues(first: 100, relationship: BLOCKED_BY) {
                        nodes { number state }
                      }
                    }
                  }
                }
              `;
              const d = await github.graphql(q, { owner: repo.owner, repo: repo.repo, number: issueNumber });
              const issue = d.repository.issue;
              const blockers = issue.linkedIssues?.nodes || [];
              const openBlockers = blockers.filter(b => b.state !== 'CLOSED');
              return { issue, openBlockers };
            }

            async function assignIfUnblocked(issueNumber) {
              const { issue, openBlockers } = await getOpenBlockers(issueNumber);
              if (!issue) return;

              const blockedLabel = process.env.BLOCKED_LABEL?.trim();
              const requiresBlockedLabel = !!blockedLabel;
              const hasBlockedLabel = blockedLabel
                ? issue.labels.nodes.some(l => l.name.toLowerCase() === blockedLabel.toLowerCase())
                : true; // no gating

              // Only proceed if no open blockers remain and (optionally) the issue is labelled as blocked
              if (openBlockers.length === 0 && hasBlockedLabel) {
                // Decide assignee
                const configured = (process.env.DEFAULT_ASSIGNEE || '').trim();
                const candidateAssignees = [];
                if (configured) {
                  // allow comma-separated list
                  for (const a of configured.split(',').map(s => s.trim()).filter(Boolean)) {
                    candidateAssignees.push(a);
                  }
                } else if (issue.author?.login) {
                  // Fallback: assign back to author (only works if they have permission to be assigned)
                  candidateAssignees.push(issue.author.login);
                } else {
                  // Final fallback: repo owner
                  candidateAssignees.push(repo.owner);
                }

                // Skip if already assigned to any of the candidates
                const already = issue.assignees.nodes.map(a => a.login.toLowerCase());
                const toAssign = candidateAssignees.filter(a => !already.includes(a.toLowerCase()));
                if (toAssign.length > 0) {
                  await github.rest.issues.addAssignees({
                    owner: repo.owner,
                    repo: repo.repo,
                    issue_number: issue.number,
                    assignees: toAssign
                  });
                }

                // Optionally remove a "blocked" label upon assignment
                const removeLabel = (process.env.REMOVE_LABEL_ON_ASSIGN || '').trim();
                if (removeLabel) {
                  const hasRemove = issue.labels.nodes.some(l => l.name.toLowerCase() === removeLabel.toLowerCase());
                  if (hasRemove) {
                    try {
                      await github.rest.issues.removeLabel({
                        owner: repo.owner,
                        repo: repo.repo,
                        issue_number: issue.number,
                        name: removeLabel
                      });
                    } catch (e) {
                      core.info(`Could not remove label '${removeLabel}': ${e.message}`);
                    }
                  }
                }

                core.summary
                  .addHeading('Auto-assign when unblocked', 2)
                  .addRaw(`• Issue #${issue.number} has no remaining blockers. Assigned to: ${JSON.stringify(candidateAssignees)}.\n`)
                  .write();
              }
            }

            for (const t of targets) {
              await assignIfUnblocked(t.number);
            }
