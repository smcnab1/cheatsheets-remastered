# .github/workflows/auto-assign-when-unblocked.yml
name: Auto-assign when unblocked

on:
  issues:
    types: [opened, edited, reopened, labeled, unlabeled, closed, transferred]
  pull_request:
    types: [closed]
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  pull-requests: read

concurrency:
  group: auto-assign-when-unblocked-${{ github.run_id }}
  cancel-in-progress: false

jobs:
  assign-when-unblocked:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' ||
      (github.event_name == 'pull_request' && github.event.action == 'closed') ||
      github.event_name == 'workflow_dispatch'

    steps:
      - name: Determine targets (dependants to re-check)
        id: targets
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const targets = new Set();

            function extractIssueNumber(subject) {
              if (!subject) return undefined;
              if (typeof subject.number === 'number') return subject.number;
              const url = subject.html_url || subject.url || '';
              // URLs look like .../repos/{owner}/{repo}/issues/{number}
              const m = url.match(/\/issues\/(\d+)(?:$|[/?#])/);
              return m ? parseInt(m[1], 10) : undefined;
            }

            async function collectDependants(number) {
              const iterator = github.paginate.iterator(
                github.rest.issues.listEventsForTimeline,
                {
                  owner, repo, issue_number: number, per_page: 100,
                  mediaType: { previews: ['mockingbird'] }
                }
              );
              for await (const { data } of iterator) {
                for (const ev of data) {
                  if (ev.event !== 'connected') continue;

                  // Prefer direction if present
                  const reason = ev.reason || ev.connection_type || '';
                  const n = extractIssueNumber(ev.subject);
                  if (!n) continue;

                  // If GitHub supplies direction, use only "blocks"
                  if (reason === 'blocks') {
                    targets.add(n);
                    continue;
                  }

                  // Fallback: If direction missing, still collect. We'll validate later.
                  // (Safer to include and let the second step check real blockers)
                  if (!reason) {
                    targets.add(n);
                  }
                }
              }
            }

            if (context.eventName === 'pull_request') {
              await collectDependants(context.payload.pull_request.number);
            } else if (context.eventName === 'issues') {
              const issueNum = context.payload.issue.number;

              if (context.payload.action === 'closed') {
                // Closed blocker: gather the issues it was blocking
                await collectDependants(issueNum);
              }

              // Also re-check the edited/labelled/reopened issue itself
              if (['opened','edited','reopened','labeled','unlabeled','transferred'].includes(context.payload.action)) {
                targets.add(issueNum);
              }
            }

            const list = [...targets];
            core.summary.addHeading('Auto-assign when unblocked â€” collector', 3)
              .addRaw(`Targets collected: ${JSON.stringify(list)}\n`).write();
            core.setOutput('list', JSON.stringify(list));

      - name: Assign any now-unblocked issues
        if: steps.targets.outputs.list != ''
        uses: actions/github-script@v7
        env:
          TARGETS: ${{ steps.targets.outputs.list }}
          DEFAULT_ASSIGNEE: ${{ vars.DEFAULT_ASSIGNEE }}         # e.g. "smcnab1" or "nexoroid,smcnab1"
          BLOCKED_LABEL: ${{ vars.BLOCKED_LABEL }}               # optional
          REMOVE_LABEL_ON_ASSIGN: ${{ vars.REMOVE_LABEL_ON_ASSIGN }} # optional
        with:
          script: |
            const { owner, repo } = context.repo;

            async function getOpenBlockers(issueNumber) {
              const openBlockers = new Set();
              const iterator = github.paginate.iterator(
                github.rest.issues.listEventsForTimeline,
                {
                  owner, repo, issue_number: issueNumber, per_page: 100,
                  mediaType: { previews: ['mockingbird'] }
                }
              );
              for await (const { data } of iterator) {
                for (const ev of data) {
                  if (ev.event === 'connected' && (ev.reason === 'blocked_by' || ev.connection_type === 'blocked_by')) {
                    // Extract blocker number robustly
                    const subject = ev.subject || {};
                    const num = typeof subject.number === 'number'
                      ? subject.number
                      : ((subject.html_url || sub_
