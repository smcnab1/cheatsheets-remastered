# .github/workflows/auto-assign-when-unblocked.yml
name: Auto-assign when unblocked

on:
  issues:
    types: [opened, edited, reopened, labeled, unlabeled, closed]
  pull_request:
    types: [closed]

permissions:
  issues: write
  contents: read

concurrency:
  group: auto-assign-when-unblocked-${{ github.event_name }}-${{ github.event.issue.number || github.event.pull_request.number || 'na' }}
  cancel-in-progress: false

jobs:
  assign-when-unblocked:
    name: Assign when all blockers are resolved
    runs-on: ubuntu-latest
    if: |
      (github.event_name == 'issues') ||
      (github.event_name == 'pull_request' && github.event.action == 'closed')

    steps:
      - name: Determine target issues to evaluate
        id: targets
        uses: actions/github-script@v7
        with:
          script: |
            const isIssueEvent = context.eventName === 'issues';
            const targets = [];

            if (isIssueEvent) {
              targets.push({ number: context.payload.issue.number });
            } else {
              const prNodeId = context.payload.pull_request.node_id;
              const q = `
                query ($nodeId: ID!) {
                  node(id: $nodeId) {
                    ... on PullRequest {
                      linkedIssues(first: 100, relationship: BLOCKS) {
                        nodes { number }
                      }
                    }
                  }
                }
              `;
              const data = await github.graphql(q, { nodeId: prNodeId });
              const nodes = new Set((data.node?.linkedIssues?.nodes || []).map(n => n.number).filter(Boolean));
              for (const n of nodes) targets.push({ number: n });
            }

            core.setOutput('list', JSON.stringify(targets));

      - name: Assign any now-unblocked issues
        uses: actions/github-script@v7
        env:
          LIST: ${{ steps.targets.outputs.list }}   # <-- pass prior step output here
          DEFAULT_ASSIGNEE: ${{ vars.DEFAULT_ASSIGNEE }}
          BLOCKED_LABEL: ${{ vars.BLOCKED_LABEL }}
          REMOVE_LABEL_ON_ASSIGN: ${{ vars.REMOVE_LABEL_ON_ASSIGN }}
        with:
          script: |
            const repo = context.repo;
            const raw = process.env.LIST || '[]';
            let targets;
            try { targets = JSON.parse(raw); } catch { targets = []; }

            if (!Array.isArray(targets) || targets.length === 0) {
              core.info('No target issues to evaluate.');
              await core.summary.addHeading('Auto-assign when unblocked', 2)
                .addRaw('• No targets to evaluate for this event.\n').write();
              return;
            }

            async function getOpenBlockers(issueNumber) {
              const q = `
                query ($owner:String!, $repo:String!, $number:Int!) {
                  repository(owner:$owner, name:$repo) {
                    issue(number:$number) {
                      number
                      state
                      labels(first: 50) { nodes { name } }
                      assignees(first: 10) { nodes { login } }
                      author { login }
                      linkedIssues(first: 100, relationship: BLOCKED_BY) {
                        nodes { number state }
                      }
                    }
                  }
                }
              `;
              const d = await github.graphql(q, { owner: repo.owner, repo: repo.repo, number: issueNumber });
              const issue = d.repository.issue;
              const blockers = issue.linkedIssues?.nodes || [];
              const openBlockers = blockers.filter(b => b.state !== 'CLOSED');
              return { issue, openBlockers };
            }

            async function assignIfUnblocked(issueNumber) {
              const { issue, openBlockers } = await getOpenBlockers(issueNumber);
              if (!issue) return;

              const blockedLabel = (process.env.BLOCKED_LABEL || '').trim();
              const hasBlockedLabel = blockedLabel
                ? issue.labels.nodes.some(l => l.name.toLowerCase() === blockedLabel.toLowerCase())
                : true;

              if (openBlockers.length === 0 && hasBlockedLabel) {
                const configured = (process.env.DEFAULT_ASSIGNEE || '').trim();
                const candidateAssignees = configured
                  ? configured.split(',').map(s => s.trim()).filter(Boolean)
                  : [issue.author?.login || repo.owner];

                const already = issue.assignees.nodes.map(a => a.login.toLowerCase());
                const toAssign = candidateAssignees.filter(a => !!a && !already.includes(a.toLowerCase()));

                if (toAssign.length > 0) {
                  await github.rest.issues.addAssignees({
                    owner: repo.owner,
                    repo: repo.repo,
                    issue_number: issue.number,
                    assignees: toAssign
                  });
                }

                const removeLabel = (process.env.REMOVE_LABEL_ON_ASSIGN || '').trim();
                if (removeLabel && issue.labels.nodes.some(l => l.name.toLowerCase() === removeLabel.toLowerCase())) {
                  try {
                    await github.rest.issues.removeLabel({
                      owner: repo.owner,
                      repo: repo.repo,
                      issue_number: issue.number,
                      name: removeLabel
                    });
                  } catch (e) {
                    core.info(`Could not remove label '${removeLabel}': ${e.message}`);
                  }
                }

                await core.summary.addHeading('Auto-assign when unblocked', 2)
                  .addRaw(`• Issue #${issue.number} has no remaining blockers. Assigned to: ${JSON.stringify(candidateAssignees)}.\n`)
                  .write();

              } else {
                await core.summary.addHeading('Auto-assign when unblocked', 2)
                  .addRaw(`• Issue #${issue.number} still has ${openBlockers.length} open blocker(s) or does not meet label gating.\n`)
                  .write();
              }
            }

            for (const t of targets) {
              await assignIfUnblocked(t.number);
            }
