name: Auto-assign when unblocked

on:
  issues:
    types: [opened, edited, reopened, labeled, unlabeled, closed, transferred]
  pull_request:
    types: [closed]
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  pull-requests: read

concurrency:
  group: auto-assign-when-unblocked-${{ github.run_id }}
  cancel-in-progress: false

jobs:
  assign-when-unblocked:
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issues' ||
      (github.event_name == 'pull_request' && github.event.action == 'closed') ||
      github.event_name == 'workflow_dispatch'

    steps:
      - name: Determine targets (dependants to re-check)
        id: targets
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const targets = new Set();

            // Helper: collect issues this item *blocks*
            async function collectDependants(number) {
              const iterator = github.paginate.iterator(
                github.rest.issues.listEventsForTimeline,
                {
                  owner, repo, issue_number: number, per_page: 100,
                  mediaType: { previews: ['mockingbird'] }
                }
              );
              for await (const { data } of iterator) {
                for (const ev of data) {
                  if (ev.event === 'connected' && (ev.reason === 'blocks' || ev.connection_type === 'blocks')) {
                    const n = ev?.subject?.number;
                    if (typeof n === 'number') targets.add(n);
                  }
                }
              }
            }

            if (context.eventName === 'pull_request') {
              // PR closed: re-check issues it blocks
              await collectDependants(context.payload.pull_request.number);
            } else if (context.eventName === 'issues') {
              const issueNum = context.payload.issue.number;

              // Always re-check the current issue's dependants when it *closes* (unblocks others).
              if (context.payload.action === 'closed') {
                await collectDependants(issueNum);
              }

              // Optional: also re-check the issue itself on edits/labels (in case blockers changed)
              if (['opened','edited','reopened','labeled','unlabeled','transferred'].includes(context.payload.action)) {
                targets.add(issueNum);
              }
            }

            core.setOutput('list', JSON.stringify([...targets]));

      - name: Assign any now-unblocked issues
        if: steps.targets.outputs.list != ''
        uses: actions/github-script@v7
        env:
          TARGETS: ${{ steps.targets.outputs.list }}
          DEFAULT_ASSIGNEE: ${{ vars.DEFAULT_ASSIGNEE }}         # e.g. "smcnab1" or "nexoroid,smcnab1"
          BLOCKED_LABEL: ${{ vars.BLOCKED_LABEL }}               # optional: gate by label (leave empty to ignore)
          REMOVE_LABEL_ON_ASSIGN: ${{ vars.REMOVE_LABEL_ON_ASSIGN }} # optional: e.g. "blocked"
        with:
          script: |
            const { owner, repo } = context.repo;

            async function getOpenBlockers(issueNumber) {
              const openBlockers = new Set();
              const iterator = github.paginate.iterator(
                github.rest.issues.listEventsForTimeline,
                {
                  owner, repo, issue_number: issueNumber, per_page: 100,
                  mediaType: { previews: ['mockingbird'] }
                }
              );
              for await (const { data } of iterator) {
                for (const ev of data) {
                  if (ev.event === 'connected' && (ev.reason === 'blocked_by' || ev.connection_type === 'blocked_by')) {
                    const n = ev?.subject?.number;
                    if (typeof n === 'number') openBlockers.add(n);
                  }
                }
              }
              const stillOpen = [];
              for (const n of openBlockers) {
                try {
                  const r = await github.rest.issues.get({ owner, repo, issue_number: n });
                  if (r.data.state !== 'closed') stillOpen.push(n);
                } catch (e) {
                  // Be conservative if fetch fails
                  stillOpen.push(n);
                }
              }
              return stillOpen;
            }

            async function fetchIssue(issueNumber) {
              const r = await github.rest.issues.get({ owner, repo, issue_number: issueNumber });
              return r.data;
            }

            async function assignIfUnblocked(issueNumber) {
              const issue = await fetchIssue(issueNumber);
              if (!issue || issue.pull_request) return;       // skip PRs
              if (issue.state === 'closed') return;           // don't assign closed issues

              const blockedLabel = (process.env.BLOCKED_LABEL || '').trim().toLowerCase();
              const hasBlockedLabel = blockedLabel
                ? (issue.labels || []).some(l => (typeof l === 'string' ? l : l.name).toLowerCase() === blockedLabel)
                : true;

              const openBlockers = await getOpenBlockers(issue.number);

              if (openBlockers.length === 0 && hasBlockedLabel) {
                const configured = (process.env.DEFAULT_ASSIGNEE || '').trim();
                const candidates = configured
                  ? configured.split(',').map(s => s.trim()).filter(Boolean)
                  : [issue.user?.login || owner];

                const already = (issue.assignees || []).map(a => a.login.toLowerCase());
                const toAssign = candidates.filter(c => !already.includes(c.toLowerCase()));

                if (toAssign.length > 0) {
                  await github.rest.issues.addAssignees({ owner, repo, issue_number: issue.number, assignees: toAssign });
                }

                const removeLabel = (process.env.REMOVE_LABEL_ON_ASSIGN || '').trim().toLowerCase();
                if (removeLabel) {
                  const hasLabel = (issue.labels || []).some(l => (typeof l === 'string' ? l : l.name).toLowerCase() === removeLabel);
                  if (hasLabel) {
                    try {
                      await github.rest.issues.removeLabel({ owner, repo, issue_number: issue.number, name: removeLabel });
                    } catch (e) {
                      core.info(`Could not remove label '${removeLabel}': ${e.message}`);
                    }
                  }
                }

                await core.summary
                  .addHeading('Auto-assign when unblocked', 2)
                  .addRaw(`â€¢ Issue #${issue.number} is now unblocked. Assigned to: ${JSON.stringify(candidates)}.\n`)
                  .write();
              }
            }

            const targets = JSON.parse(process.env.TARGETS || '[]');
            for (const n of targets) {
              await assignIfUnblocked(n);
            }
